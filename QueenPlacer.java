/* Copyright 2010, Joseph Bergin * Creative Commons Attribution-Noncommercial 3.0 United States License */public class QueenPlacer extends AugmentedRobot{	public QueenPlacer() 	{		super(1, 1, NORTH, KarelWorld.INFINITE);	}	int totalPuts = 0;	/** Read an 8 by 8 "chessboard" and initialize a QueenPlacer at the origin */	public static void populate()	{		KarelWorld world = KarelWorld.itself();		world.readWorld("worlds", "chess.kwld");		// QueenPlacer karel = new QueenPlacer();	}	/** Print a short usage note to standard output. */	public static String usage()	{		System.out.println("\nFirst execute populate() to get the world and a robot.");		System.out				.println("Then push the Act button or send the robot the act() message.");		System.out.println("The robot will attempt to place queens properly.");		return "See the output listing.";	}	void goToWall()	{		while (frontIsClear())		{			move();		}	}	void goToNextRow()	{		faceNorth();		if (frontIsClear())		{			move();		}		turnLeft();		goToWall();	}	boolean goToPreviousRow()	// Changes position and direction.	{		faceSouth();		if (frontIsClear())		{			move();		} else		{			return false;			// This occurs when no correct position on 1st Street is possible.		}		turnRight();		goToWall();		return true;	}	void moveQueen()	// Move to right on current row. At end move back to West wall.	{		pickBeeper();		faceEast();		if (frontIsClear())		{			move();			putBeeper();			totalPuts++;		} else		{			turnAround();			goToWall();			turnAround();			putBeeper();			totalPuts++;		}	}	void findQueen()	// Only checks to right of current position.	{		faceEast();		while (!nextToABeeper())		{			move();		}	}	boolean attackVertical()	// Does not alter position. May alter direction.	{		faceSouth();		if (frontIsClear())		{			move();			if (nextToABeeper())			{				faceNorth();				move();				return true;			} else			{				if (attackVertical())				{					faceNorth();					move();					return true;				} else				{					faceNorth();					move();					return false;				}			}		} else		{			return false;		}	}	boolean attackDownRight()	// Does not alter position. May alter direction.	{		faceSouth();		if (frontIsClear())		{			turnLeft();			if (frontIsClear())			{				move();				turnRight();				move();				if (nextToABeeper())				{					faceNorth();					move();					turnLeft();					move();					return true;				} else				{					if (attackDownRight())					{						faceNorth();						move();						turnLeft();						move();						return true;					} else					{						faceNorth();						move();						turnLeft();						move();						return false;					}				}			} else			{				return false;			}		} else		{			return false;		}	}	boolean attackDownLeft()	// Does not alter position. May alter direction.	{		faceSouth();		if (frontIsClear())		{			turnRight();			if (frontIsClear())			{				move();				turnLeft();				move();				if (nextToABeeper())				{					faceNorth();					move();					turnRight();					move();					return true;				} else				{					if (attackDownLeft())					{						faceNorth();						move();						turnRight();						move();						return true;					} else					{						faceNorth();						move();						turnRight();						move();						return false;					}				}			} else			{				return false;			}		} else		{			return false;		}	}	boolean anyBeepersInRow()	// Does not alter position. May alter direction.	// Only checks to right of current location.	{		if (nextToABeeper())		{			return true;		} else		{			faceEast();			if (!frontIsClear())			{				return false;			} else			{				move();				if (anyBeepersInRow())				{					faceWest();					move();					return true;				} else				{					faceWest();					move();					return false;				}			}		}	}	boolean placeQueens()	// The program will return false error if modified to attempt a situation	// in which there is no solution (e.g. 3 by 3).	// In spite of the complexity of the recursion, it is all tail recursion.	// This is the only reason for making this a boolean function.	{		if (true)		{			if (!anyBeepersInRow())			{				putBeeper();				totalPuts++;			}			findQueen();			if (attackVertical())			{				faceEast();				if (!frontIsClear())				{					moveQueen();					if (!goToPreviousRow())					{						return false;					}					findQueen();					faceEast();					if (!frontIsClear())					{						if (!goToPreviousRow())						{							return false;						}						findQueen();					}				}				moveQueen();				return placeQueens();			}			if (attackDownLeft())			{				faceEast();				if (!frontIsClear())				{					moveQueen();					if (!goToPreviousRow())					{						return false;					}					findQueen();					faceEast();					if (!frontIsClear())					{						if (!goToPreviousRow())						{							return false;						}						findQueen();					}				}				moveQueen();				return placeQueens();			}			if (attackDownRight())			{				faceEast();				if (!frontIsClear())				{					moveQueen();					if (!goToPreviousRow())					{						return false;					}					findQueen();					faceEast();					if (!frontIsClear())					{						if (!goToPreviousRow())						{							return false;						}						findQueen();					}				}				moveQueen();				return placeQueens();			}			faceNorth();			if (!frontIsClear())			{				return true;			}			goToNextRow();			faceEast();			return placeQueens();		}		return true; // This is actually dead code, but Eclipse reports an error if						// omitted.	}	/** Attempt to place all of the queens */	public void act()	{		if (placeQueens())		{			/* nothing */		}		turnOff();	}}